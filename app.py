# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e1F641bTkh-6yAaPNj3dlCt_OI3W6l3d
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

df = pd.read_csv('/content/insurance.csv')
df.head()

# INSTALACIÓN DE LIBRERÍAS
!pip install gradio scikit-learn pandas numpy matplotlib seaborn plotly -q

# IMPORTACIÓN DE LIBRERÍAS
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

from sklearn.model_selection import train_test_split, cross_val_score, GridSearchCV
from sklearn.linear_model import LinearRegression, LogisticRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.metrics import (mean_squared_error, r2_score, accuracy_score,
                            classification_report, confusion_matrix, roc_curve,
                            auc, roc_auc_score, f1_score, precision_score, recall_score)
from sklearn.preprocessing import StandardScaler
from scipy import stats

# Configuración de visualización
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")

print("="*70)
print("SISTEMA DE PREDICCIÓN MÉDICA CON MACHINE LEARNING")
print("="*70)
print("\n✓ Librerías cargadas correctamente\n")

# Cargar datasets
insurance_df = pd.read_csv('insurance.csv')
diabetes_df = pd.read_csv('diabetes.csv')

print("\n📊 DATASET DE SEGUROS MÉDICOS:")
print("-" * 70)
print(insurance_df.head())
print(f"\nDimensiones: {insurance_df.shape}")
print(f"Columnas: {list(insurance_df.columns)}")

print("\n📊 DATASET DE DIABETES:")
print("-" * 70)
print(diabetes_df.head())
print(f"\nDimensiones: {diabetes_df.shape}")
print(f"Columnas: {list(diabetes_df.columns)}")


# Detectar columna objetivo en diabetes
posibles_nombres_outcome = ['Outcome', 'outcome', 'Diabetes', 'diabetes',
                            'target', 'Target', 'class', 'Class', 'label', 'Label']

diabetes_target_col = None
for nombre in posibles_nombres_outcome:
    if nombre in diabetes_df.columns:
        diabetes_target_col = nombre
        break

if diabetes_target_col is None:
    diabetes_target_col = diabetes_df.columns[-1]

print(f"\n✓ Columna objetivo detectada: '{diabetes_target_col}'")
print(f"Valores únicos: {diabetes_df[diabetes_target_col].unique()}")

# Normalizar a 0 y 1 si es necesario
if set(diabetes_df[diabetes_target_col].unique()) != {0, 1}:
    unique_vals = sorted(diabetes_df[diabetes_target_col].unique())
    if len(unique_vals) == 2:
        diabetes_df[diabetes_target_col] = diabetes_df[diabetes_target_col].map({
            unique_vals[0]: 0, unique_vals[1]: 1
        })
        print(f"✓ Valores normalizados: {unique_vals[0]}→0, {unique_vals[1]}→1")


# ============================================
# PREGUNTA 5: CONTEXTO DE LOS DATOS
# ============================================

print("\n" + "="*70)
print("PREGUNTA 5: EXPLICAR CONTEXTO DE LOS DATOS")
print("="*70)

print("\n📋 1. DATASET DE SEGUROS MÉDICOS")
print("-" * 70)
print("""
DESCRIPCIÓN:
Dataset con información de beneficiarios de seguros médicos en USA.
Objetivo: Predecir los costos médicos individuales facturados por el seguro.

VARIABLES:
- age: Edad del beneficiario
- sex: Género del beneficiario
- bmi: Índice de Masa Corporal
- children: Número de hijos/dependientes
- smoker: Si el beneficiario es fumador
- region: Región de residencia en USA
- charges: Costos médicos individuales (VARIABLE OBJETIVO)
""")
print("\nESTADÍSTICAS DESCRIPTIVAS:")
print(insurance_df.describe())

print("\n\n📋 2. DATASET DE DIABETES")
print("-" * 70)
print(f"""
DESCRIPCIÓN:
Dataset con datos de pacientes para predicción de diabetes.
Contiene {diabetes_df.shape[0]} registros.
Objetivo: Predecir si un paciente tiene diabetes.

COLUMNAS:
{diabetes_df.columns.tolist()}
""")
print("\nESTADÍSTICAS DESCRIPTIVAS:")
print(diabetes_df.describe())

print(f"\nDISTRIBUCIÓN DE LA VARIABLE OBJETIVO ('{diabetes_target_col}'):")
print(diabetes_df[diabetes_target_col].value_counts())
print(f"\nPorcentaje con diabetes: {diabetes_df[diabetes_target_col].mean()*100:.2f}%")
print(f"Porcentaje sin diabetes: {(1-diabetes_df[diabetes_target_col].mean())*100:.2f}%")

# Visualizaciones
fig, axes = plt.subplots(2, 3, figsize=(18, 10))
fig.suptitle('ANÁLISIS EXPLORATORIO DE DATOS', fontsize=16, fontweight='bold')

# SEGUROS
axes[0, 0].hist(insurance_df['charges'], bins=50, edgecolor='black', color='skyblue')
axes[0, 0].set_title('Distribución de Costos de Seguro')
axes[0, 0].set_xlabel('Charges ($)')
axes[0, 0].set_ylabel('Frecuencia')

if 'smoker' in insurance_df.columns:
    insurance_df.boxplot(column='charges', by='smoker', ax=axes[0, 1])
    axes[0, 1].set_title('Costos por Fumador')

axes[0, 2].scatter(insurance_df['age'], insurance_df['charges'], alpha=0.5, color='coral')
axes[0, 2].set_title('Edad vs Costos')

# DIABETES
diabetes_df[diabetes_target_col].value_counts().plot(kind='bar', ax=axes[1, 0], color=['green', 'red'])
axes[1, 0].set_title('Distribución de Diabetes')
axes[1, 0].set_xticklabels(['No Diabetes', 'Diabetes'], rotation=0)

corr = diabetes_df.corr()[diabetes_target_col].sort_values(ascending=False)[1:]
corr.plot(kind='barh', ax=axes[1, 1], color='purple')
axes[1, 1].set_title(f'Correlación con {diabetes_target_col}')

numeric_cols = diabetes_df.select_dtypes(include=[np.number]).columns.tolist()
numeric_cols.remove(diabetes_target_col)
if len(numeric_cols) >= 2:
    axes[1, 2].scatter(diabetes_df[numeric_cols[0]], diabetes_df[numeric_cols[1]],
                       c=diabetes_df[diabetes_target_col], cmap='coolwarm', alpha=0.6)
    axes[1, 2].set_title(f'{numeric_cols[0]} vs {numeric_cols[1]}')

plt.tight_layout()
plt.show()


# SEGUROS
print("\n🔧 Preprocesando datos de seguros...")
insurance_processed = insurance_df.copy()

if 'sex' in insurance_processed.columns:
    insurance_processed['sex'] = insurance_processed['sex'].map({
        'male': 1, 'female': 0, 'Male': 1, 'Female': 0
    })

if 'smoker' in insurance_processed.columns:
    insurance_processed['smoker'] = insurance_processed['smoker'].map({
        'yes': 1, 'no': 0, 'Yes': 1, 'No': 0
    })

if 'region' in insurance_processed.columns:
    insurance_processed = pd.get_dummies(insurance_processed, columns=['region'], drop_first=True)

X_insurance = insurance_processed.drop('charges', axis=1)
y_insurance = insurance_processed['charges']

X_train_ins, X_test_ins, y_train_ins, y_test_ins = train_test_split(
    X_insurance, y_insurance, test_size=0.2, random_state=42
)
print(f"✓ Train set: {X_train_ins.shape}, Test set: {X_test_ins.shape}")

# DIABETES
print("\n🔧 Preprocesando datos de diabetes...")
X_diabetes = diabetes_df.drop(diabetes_target_col, axis=1)
y_diabetes = diabetes_df[diabetes_target_col]

X_train_diab, X_test_diab, y_train_diab, y_test_diab = train_test_split(
    X_diabetes, y_diabetes, test_size=0.2, random_state=42
)

scaler = StandardScaler()
X_train_diab_scaled = scaler.fit_transform(X_train_diab)
X_test_diab_scaled = scaler.transform(X_test_diab)
print(f"✓ Train set: {X_train_diab.shape}, Test set: {X_test_diab.shape}")



print("\n Entrenando modelo de Regresión Lineal (Seguros)...")
lr_model = LinearRegression()
lr_model.fit(X_train_ins, y_train_ins)
y_pred_ins = lr_model.predict(X_test_ins)

print(f"✓ R² Score: {r2_score(y_test_ins, y_pred_ins):.4f}")
print(f"✓ RMSE: ${np.sqrt(mean_squared_error(y_test_ins, y_pred_ins)):,.2f}")

print("\n Entrenando modelo de Regresión Logística (Diabetes)...")
log_model = LogisticRegression(max_iter=1000, random_state=42)
log_model.fit(X_train_diab_scaled, y_train_diab)
y_pred_diab_base = log_model.predict(X_test_diab_scaled)

print(f"✓ Accuracy: {accuracy_score(y_test_diab, y_pred_diab_base):.4f}")


# PREGUNTA 1: UMBRAL IDEAL PARA DIABETES

print("\n" + "="*70)
print("PREGUNTA 1: ¿CUÁL ES EL UMBRAL IDEAL PARA DIABETES?")
print("="*70)

y_pred_proba = log_model.predict_proba(X_test_diab_scaled)[:, 1]

thresholds = np.arange(0.1, 0.9, 0.05)
accuracies = []
f1_scores = []
precisions = []
recalls = []

for threshold in thresholds:
    y_pred_threshold = (y_pred_proba >= threshold).astype(int)
    accuracies.append(accuracy_score(y_test_diab, y_pred_threshold))
    f1_scores.append(f1_score(y_test_diab, y_pred_threshold))
    precisions.append(precision_score(y_test_diab, y_pred_threshold, zero_division=0))
    recalls.append(recall_score(y_test_diab, y_pred_threshold))

best_threshold_idx = np.argmax(f1_scores)
best_threshold = thresholds[best_threshold_idx]

print(f"\n📊 RESULTADO:")
print(f"  ✓ Umbral Ideal: {best_threshold:.2f}")
print(f"  ✓ F1-Score: {f1_scores[best_threshold_idx]:.4f}")
print(f"  ✓ Accuracy: {accuracies[best_threshold_idx]:.4f}")
print(f"  ✓ Precision: {precisions[best_threshold_idx]:.4f}")
print(f"  ✓ Recall: {recalls[best_threshold_idx]:.4f}")

# Visualización
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

axes[0].plot(thresholds, accuracies, label='Accuracy', marker='o', linewidth=2)
axes[0].plot(thresholds, f1_scores, label='F1-Score', marker='s', linewidth=2)
axes[0].plot(thresholds, precisions, label='Precision', marker='^', linewidth=2)
axes[0].plot(thresholds, recalls, label='Recall', marker='v', linewidth=2)
axes[0].axvline(best_threshold, color='red', linestyle='--', linewidth=2,
                label=f'Umbral Óptimo: {best_threshold:.2f}')
axes[0].set_xlabel('Umbral', fontsize=12)
axes[0].set_ylabel('Score', fontsize=12)
axes[0].set_title('Pregunta 1: Análisis de Umbrales', fontsize=14, fontweight='bold')
axes[0].legend(loc='best')
axes[0].grid(True, alpha=0.3)

fpr, tpr, _ = roc_curve(y_test_diab, y_pred_proba)
roc_auc = auc(fpr, tpr)

axes[1].plot(fpr, tpr, label=f'ROC curve (AUC = {roc_auc:.3f})', linewidth=2, color='darkblue')
axes[1].plot([0, 1], [0, 1], 'k--', linewidth=2, label='Random')
axes[1].set_xlabel('False Positive Rate', fontsize=12)
axes[1].set_ylabel('True Positive Rate', fontsize=12)
axes[1].set_title('Curva ROC', fontsize=14, fontweight='bold')
axes[1].legend(loc='best')
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

y_pred_diab = (y_pred_proba >= best_threshold).astype(int)

print("\n MATRIZ DE CONFUSIÓN:")
cm = confusion_matrix(y_test_diab, y_pred_diab)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', cbar=False)
plt.title(f'Matriz de Confusión (Umbral = {best_threshold:.2f})', fontsize=14, fontweight='bold')
plt.ylabel('Real')
plt.xlabel('Predicción')
plt.show()

print("\n📋 REPORTE DE CLASIFICACIÓN:")
print(classification_report(y_test_diab, y_pred_diab, target_names=['No Diabetes', 'Diabetes']))

# PREGUNTA 2: FACTORES INFLUYENTES

print("\n" + "="*70)
print("PREGUNTA 2: ¿CUÁLES SON LOS FACTORES QUE MÁS INFLUYEN EN EL COSTO?")
print("="*70)

feature_importance_lr = pd.DataFrame({
    'Feature': X_insurance.columns,
    'Coefficient': lr_model.coef_,
    'Abs_Coefficient': np.abs(lr_model.coef_)
}).sort_values('Abs_Coefficient', ascending=False)

print("\n IMPORTANCIA DE VARIABLES:")
print("-" * 70)
print(feature_importance_lr[['Feature', 'Coefficient', 'Abs_Coefficient']].to_string(index=False))

print("\n TOP 3 FACTORES:")
for i, (idx, row) in enumerate(feature_importance_lr.head(3).iterrows(), 1):
    print(f"  {i}. {row['Feature']}: ${abs(row['Coefficient']):,.2f}")

# Visualización
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

colors = ['red' if i < 3 else 'skyblue' for i in range(len(feature_importance_lr))]
axes[0].barh(feature_importance_lr['Feature'], feature_importance_lr['Abs_Coefficient'], color=colors)
axes[0].set_xlabel('Coeficiente Absoluto', fontsize=12)
axes[0].set_title('Pregunta 2: Importancia de Variables', fontsize=14, fontweight='bold')
axes[0].grid(axis='x', alpha=0.3)

colors_signed = ['green' if c > 0 else 'orange' for c in feature_importance_lr['Coefficient']]
axes[1].barh(feature_importance_lr['Feature'], feature_importance_lr['Coefficient'], color=colors_signed)
axes[1].set_xlabel('Coeficiente (con signo)', fontsize=12)
axes[1].set_title('Impacto Direccional', fontsize=14, fontweight='bold')
axes[1].axvline(0, color='black', linewidth=0.8)
axes[1].grid(axis='x', alpha=0.3)

plt.tight_layout()
plt.show()

# PREGUNTA 3: RANDOM FOREST

print("\n" + "="*70)
print("PREGUNTA 3: ANÁLISIS COMPARATIVO CON RANDOM FOREST")
print("="*70)

print("\n Entrenando Random Forest (Seguros)...")
rf_insurance = RandomForestRegressor(n_estimators=100, random_state=42, max_depth=10, n_jobs=-1)
rf_insurance.fit(X_train_ins, y_train_ins)
y_pred_rf_ins = rf_insurance.predict(X_test_ins)

rf_r2 = r2_score(y_test_ins, y_pred_rf_ins)
rf_rmse = np.sqrt(mean_squared_error(y_test_ins, y_pred_rf_ins))

print(f"✓ R² Score: {rf_r2:.4f}")
print(f"✓ RMSE: ${rf_rmse:,.2f}")

rf_importance_ins = pd.DataFrame({
    'Feature': X_insurance.columns,
    'Importance': rf_insurance.feature_importances_
}).sort_values('Importance', ascending=False)

print("\n IMPORTANCIA RF (Seguros):")
print(rf_importance_ins.to_string(index=False))

print("\🌲 Entrenando Random Forest (Diabetes)...")
rf_diabetes = RandomForestClassifier(n_estimators=100, random_state=42, max_depth=10, n_jobs=-1)
rf_diabetes.fit(X_train_diab_scaled, y_train_diab)
y_pred_rf_diab = rf_diabetes.predict(X_test_diab_scaled)
y_pred_rf_diab_proba = rf_diabetes.predict_proba(X_test_diab_scaled)[:, 1]

rf_acc = accuracy_score(y_test_diab, y_pred_rf_diab)
rf_roc_auc = roc_auc_score(y_test_diab, y_pred_rf_diab_proba)

print(f"✓ Accuracy: {rf_acc:.4f}")
print(f"✓ ROC-AUC: {rf_roc_auc:.4f}")

rf_importance_diab = pd.DataFrame({
    'Feature': X_diabetes.columns,
    'Importance': rf_diabetes.feature_importances_
}).sort_values('Importance', ascending=False)

print("\n IMPORTANCIA RF (Diabetes):")
print(rf_importance_diab.to_string(index=False))

print("\n" + "="*70)
print("COMPARACIÓN DE MODELOS")
print("="*70)

print("\n SEGUROS:")
comparison_ins = pd.DataFrame({
    'Modelo': ['Regresión Lineal', 'Random Forest'],
    'R² Score': [r2_score(y_test_ins, y_pred_ins), rf_r2],
    'RMSE': [np.sqrt(mean_squared_error(y_test_ins, y_pred_ins)), rf_rmse]
})
print(comparison_ins.to_string(index=False))

print("\n DIABETES:")
comparison_diab = pd.DataFrame({
    'Modelo': ['Regresión Logística', 'Random Forest'],
    'Accuracy': [accuracy_score(y_test_diab, y_pred_diab), rf_acc],
    'ROC-AUC': [roc_auc_score(y_test_diab, y_pred_proba), rf_roc_auc]
})
print(comparison_diab.to_string(index=False))

# Visualización
fig, axes = plt.subplots(2, 2, figsize=(18, 12))
fig.suptitle('Pregunta 3: Análisis con Random Forest', fontsize=16, fontweight='bold')

axes[0, 0].barh(rf_importance_ins['Feature'], rf_importance_ins['Importance'], color='steelblue')
axes[0, 0].set_xlabel('Importancia')
axes[0, 0].set_title('RF: Importancia (Seguros)')
axes[0, 0].grid(axis='x', alpha=0.3)

x = np.arange(len(comparison_ins))
width = 0.35
axes[0, 1].bar(x, comparison_ins['R² Score'], width, label='R² Score', color='coral')
axes[0, 1].set_ylabel('R² Score')
axes[0, 1].set_title('Comparación (Seguros)')
axes[0, 1].set_xticks(x)
axes[0, 1].set_xticklabels(comparison_ins['Modelo'], rotation=15)
axes[0, 1].legend()
axes[0, 1].grid(axis='y', alpha=0.3)

axes[1, 0].barh(rf_importance_diab['Feature'], rf_importance_diab['Importance'], color='mediumseagreen')
axes[1, 0].set_xlabel('Importancia')
axes[1, 0].set_title('RF: Importancia (Diabetes)')
axes[1, 0].grid(axis='x', alpha=0.3)

x = np.arange(len(comparison_diab))
axes[1, 1].bar(x - width/2, comparison_diab['Accuracy'], width, label='Accuracy', color='gold')
axes[1, 1].bar(x + width/2, comparison_diab['ROC-AUC'], width, label='ROC-AUC', color='lightcoral')
axes[1, 1].set_ylabel('Score')
axes[1, 1].set_title('Comparación (Diabetes)')
axes[1, 1].set_xticks(x)
axes[1, 1].set_xticklabels(comparison_diab['Modelo'], rotation=15)
axes[1, 1].legend()
axes[1, 1].grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.show()

# PREGUNTA 4: OPTIMIZACIÓN

print("\n" + "="*70)
print("PREGUNTA 4: ¿QUÉ TÉCNICA MEJORA EL RENDIMIENTO?")
print("="*70)

print("\n 1. OPTIMIZACIÓN - SEGUROS")
print("-" * 70)

print("\n Probando Ridge...")
ridge_params = {'alpha': [0.001, 0.01, 0.1, 1, 10, 100]}
ridge_cv = GridSearchCV(Ridge(), ridge_params, cv=5, scoring='r2', n_jobs=-1)
ridge_cv.fit(X_train_ins, y_train_ins)
y_pred_ridge = ridge_cv.predict(X_test_ins)

print(f"  ✓ Mejor alpha: {ridge_cv.best_params_['alpha']}")
print(f"  ✓ R²: {r2_score(y_test_ins, y_pred_ridge):.4f}")

print("\n• Probando Lasso...")
lasso_cv = GridSearchCV(Lasso(max_iter=10000), ridge_params, cv=5, scoring='r2', n_jobs=-1)
lasso_cv.fit(X_train_ins, y_train_ins)
y_pred_lasso = lasso_cv.predict(X_test_ins)

print(f"  ✓ Mejor alpha: {lasso_cv.best_params_['alpha']}")
print(f"  ✓ R²: {r2_score(y_test_ins, y_pred_lasso):.4f}")

print("\n• Optimizando Random Forest...")
rf_params_ins = {
    'n_estimators': [100, 200],
    'max_depth': [10, 15, 20],
    'min_samples_split': [2, 5]
}
rf_cv_ins = GridSearchCV(RandomForestRegressor(random_state=42),
                         rf_params_ins, cv=5, scoring='r2', n_jobs=-1, verbose=0)
rf_cv_ins.fit(X_train_ins, y_train_ins)
y_pred_rf_opt_ins = rf_cv_ins.predict(X_test_ins)

print(f"  ✓ Mejores parámetros: {rf_cv_ins.best_params_}")
print(f"  ✓ R²: {r2_score(y_test_ins, y_pred_rf_opt_ins):.4f}")

print("\n 2. OPTIMIZACIÓN - DIABETES")
print("-" * 70)

print("\n• Optimizando Regresión Logística...")
log_params = {
    'C': [0.001, 0.01, 0.1, 1, 10, 100],
    'penalty': ['l1', 'l2'],
    'solver': ['liblinear']
}
log_cv = GridSearchCV(LogisticRegression(max_iter=1000, random_state=42),
                      log_params, cv=5, scoring='roc_auc', n_jobs=-1, verbose=0)
log_cv.fit(X_train_diab_scaled, y_train_diab)
y_pred_proba_opt = log_cv.predict_proba(X_test_diab_scaled)[:, 1]
y_pred_opt = (y_pred_proba_opt >= best_threshold).astype(int)

print(f"  ✓ Mejores parámetros: {log_cv.best_params_}")
print(f"  ✓ Accuracy: {accuracy_score(y_test_diab, y_pred_opt):.4f}")

print("\n Optimizando Random Forest...")
rf_params_diab = {
    'n_estimators': [100, 200],
    'max_depth': [5, 10, 15],
    'min_samples_split': [2, 5]
}
rf_cv_diab = GridSearchCV(RandomForestClassifier(random_state=42),
                          rf_params_diab, cv=5, scoring='roc_auc', n_jobs=-1, verbose=0)
rf_cv_diab.fit(X_train_diab_scaled, y_train_diab)
y_pred_rf_opt_diab = rf_cv_diab.predict(X_test_diab_scaled)
y_pred_rf_opt_diab_proba = rf_cv_diab.predict_proba(X_test_diab_scaled)[:, 1]

print(f"  ✓ Mejores parámetros: {rf_cv_diab.best_params_}")
print(f"  ✓ Accuracy: {accuracy_score(y_test_diab, y_pred_rf_opt_diab):.4f}")

print("\n" + "="*70)
print("RESUMEN DE OPTIMIZACIÓN")
print("="*70)

print("\n SEGUROS:")
optimization_ins = pd.DataFrame({
    'Modelo': ['Regresión Lineal', 'Ridge', 'Lasso', 'Random Forest', 'RF Optimizado'],
    'R² Score': [
        r2_score(y_test_ins, y_pred_ins),
        r2_score(y_test_ins, y_pred_ridge),
        r2_score(y_test_ins, y_pred_lasso),
        r2_score(y_test_ins, y_pred_rf_ins),
        r2_score(y_test_ins, y_pred_rf_opt_ins)
    ]
})
print(optimization_ins.to_string(index=False))

print("\n DIABETES:")
optimization_diab = pd.DataFrame({
    'Modelo': ['Reg. Log. Base', 'Reg. Log. Opt', 'Random Forest', 'RF Optimizado'],
    'Accuracy': [
        accuracy_score(y_test_diab, y_pred_diab),
        accuracy_score(y_test_diab, y_pred_opt),
        accuracy_score(y_test_diab, y_pred_rf_diab),
        accuracy_score(y_test_diab, y_pred_rf_opt_diab)
    ]
})
print(optimization_diab.to_string(index=False))

# Visualización
fig, axes = plt.subplots(1, 2, figsize=(16, 6))
fig.suptitle('Pregunta 4: Optimización', fontsize=16, fontweight='bold')

axes[0].bar(optimization_ins['Modelo'], optimization_ins['R² Score'],
            color=['gray', 'lightblue', 'lightgreen', 'orange', 'red'])
axes[0].set_ylabel('R² Score')
axes[0].set_title('Optimización - Seguros')
axes[0].tick_params(axis='x', rotation=45)
axes[0].grid(axis='y', alpha=0.3)

x = np.arange(len(optimization_diab))
axes[1].bar(x, optimization_diab['Accuracy'], color='steelblue')
axes[1].set_ylabel('Accuracy')
axes[1].set_title('Optimización - Diabetes')
axes[1].set_xticks(x)
axes[1].set_xticklabels(optimization_diab['Modelo'], rotation=45, ha='right')
axes[1].grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.show()

# PREGUNTA 6: SESGO

print("\n" + "="*70)
print("PREGUNTA 6: ANALIZAR EL SESGO Y EXPLICAR POR QUÉ")
print("="*70)

print("\n 1. SESGO - SEGUROS")
print("-" * 70)

insurance_analysis = insurance_df.copy()
insurance_processed_full = insurance_processed.copy()
insurance_processed_full['predicted'] = lr_model.predict(X_insurance)
insurance_processed_full['actual'] = insurance_df['charges']
insurance_processed_full['residuals'] = insurance_processed_full['actual'] - insurance_processed_full['predicted']
insurance_processed_full['sex_original'] = insurance_df['sex']
insurance_processed_full['smoker_original'] = insurance_df['smoker']

print("\n Por Género:")
by_gender = insurance_processed_full.groupby('sex_original').agg({
    'actual': ['mean', 'std'],
    'predicted': ['mean', 'std'],
    'residuals': ['mean', 'std']
}).round(2)
print(by_gender)

print("\n Por Fumador:")
by_smoker = insurance_processed_full.groupby('smoker_original').agg({
    'actual': ['mean', 'std'],
    'predicted': ['mean', 'std'],
    'residuals': ['mean', 'std']
}).round(2)
print(by_smoker)

print("\n 2. SESGO - DIABETES")
print("-" * 70)

diabetes_analysis = diabetes_df.copy()
diabetes_analysis['predicted'] = log_model.predict(scaler.transform(X_diabetes))
diabetes_analysis['predicted_proba'] = log_model.predict_proba(scaler.transform(X_diabetes))[:, 1]
diabetes_analysis['correct'] = (diabetes_analysis['predicted'] == diabetes_analysis[diabetes_target_col]).astype(int)

# Crear grupos
numeric_cols_for_binning = X_diabetes.select_dtypes(include=[np.number]).columns
if len(numeric_cols_for_binning) > 0:
    age_col = [c for c in numeric_cols_for_binning if 'age' in c.lower()]
    if age_col:
        diabetes_analysis['age_group'] = pd.cut(diabetes_analysis[age_col[0]],
                                                bins=[0, 30, 50, 100],
                                                labels=['Joven', 'Adulto', 'Mayor'])

        print("\n Por Edad:")
        by_age = diabetes_analysis.groupby('age_group').agg({
            diabetes_target_col: ['mean', 'count'],
            'predicted_proba': 'mean',
            'correct': 'mean'
        }).round(3)
        print(by_age)

print("\n Desbalance de Clases:")
class_dist = diabetes_df[diabetes_target_col].value_counts()
print(class_dist)
print(f"\nRatio: {class_dist.values[0]/class_dist.values[1]:.2f}:1")

# Visualización
fig, axes = plt.subplots(2, 2, figsize=(16, 10))
fig.suptitle('Pregunta 6: Análisis de Sesgo', fontsize=16, fontweight='bold')

insurance_processed_full.boxplot(column='residuals', by='sex_original', ax=axes[0, 0])
axes[0, 0].set_title('Residuos por Género')
axes[0, 0].axhline(0, color='red', linestyle='--')

insurance_processed_full.boxplot(column='residuals', by='smoker_original', ax=axes[0, 1])
axes[0, 1].set_title('Residuos por Fumador')
axes[0, 1].axhline(0, color='red', linestyle='--')

if 'age_group' in diabetes_analysis.columns:
    diabetes_analysis.groupby('age_group')[diabetes_target_col].mean().plot(kind='bar', ax=axes[1, 0])
    axes[1, 0].set_title('Prevalencia por Edad')
    axes[1, 0].set_ylabel('Proporción')
    axes[1, 0].tick_params(axis='x', rotation=45)

class_dist.plot(kind='bar', ax=axes[1, 1], color=['green', 'red'])
axes[1, 1].set_title('Desbalance de Clases')
axes[1, 1].set_xticklabels(['No', 'Sí'], rotation=0)

plt.tight_layout()
plt.show()

print("\n EXPLICACIÓN DEL SESGO:")
print("-" * 70)
print("""
SEGUROS:
- Sesgo hacia fumadores (factor dominante)
- Relación no lineal con BMI no capturada
- Desbalance regional en dataset
- CAUSA: Modelo lineal simple, variables omitidas

DIABETES:
- Sesgo etario (mejor en mayores)
- Desbalance de clases
- Dataset específico (mujeres Pima)
- CAUSA: Datos no representativos, desbalance

MITIGACIÓN:
- Usar Random Forest
- Técnicas de balanceo (SMOTE)
- Incluir más variables
- Validación por subgrupos
""")

# GUARDAR MODELOS

print("\n" + "="*70)
print("GUARDANDO MODELOS")
print("="*70)

import pickle

with open('insurance_model.pkl', 'wb') as f:
    pickle.dump(rf_cv_ins, f)
print("✓ insurance_model.pkl")

with open('diabetes_model.pkl', 'wb') as f:
    pickle.dump(rf_cv_diab, f)
print("✓ diabetes_model.pkl")

with open('scaler.pkl', 'wb') as f:
    pickle.dump(scaler, f)
print("✓ scaler.pkl")

with open('best_threshold.pkl', 'wb') as f:
    pickle.dump(best_threshold, f)
print(f"✓ best_threshold.pkl ({best_threshold:.2f})")

# INTERFAZ WEB CON GRADIO

print("\n" + "="*70)
print("CREANDO INTERFAZ WEB")
print("="*70)

import gradio as gr

insurance_model_final = rf_cv_ins
diabetes_model_final = rf_cv_diab

def predict_insurance(age, sex, bmi, children, smoker, region):
    try:
        sex_encoded = 1 if sex == "Masculino" else 0
        smoker_encoded = 1 if smoker == "Sí" else 0

        input_data = pd.DataFrame({
            'age': [age],
            'sex': [sex_encoded],
            'bmi': [bmi],
            'children': [children],
            'smoker': [smoker_encoded],
            'region_northwest': [1 if region == "Northwest" else 0],
            'region_southeast': [1 if region == "Southeast" else 0],
            'region_southwest': [1 if region == "Southwest" else 0]
        })

        prediction = insurance_model_final.predict(input_data)[0]

        if prediction < 5000:
            categoria = "💚 Bajo"
        elif prediction < 15000:
            categoria = "💛 Moderado"
        else:
            categoria = "🔴 Alto"

        return f"""
### 💰 Costo Estimado: ${prediction:,.2f}
**Categoría:** {categoria}

**Factores:**
- Edad: {age} años
- IMC: {bmi:.1f} {'⚠️' if bmi > 30 else '✓'}
- Fumador: {'Sí ⚠️' if smoker == 'Sí' else 'No ✓'}
- Hijos: {children}
"""
    except Exception as e:
        return f"❌ Error: {str(e)}"


def predict_diabetes(pregnancies, glucose, blood_pressure, skin_thickness,
                    insulin, bmi, dpf, age):
    try:
        input_data = np.array([[pregnancies, glucose, blood_pressure, skin_thickness,
                               insulin, bmi, dpf, age]])

        input_scaled = scaler.transform(input_data)
        prediction_proba = diabetes_model_final.predict_proba(input_scaled)[0][1]
        prediction = prediction_proba >= best_threshold

        if prediction_proba < 0.3:
            riesgo = "🟢 Bajo"
        elif prediction_proba < 0.6:
            riesgo = "🟡 Moderado"
        else:
            riesgo = "🔴 Alto"

        return f"""
### {'🔴 POSITIVO - Riesgo de Diabetes' if prediction else '✅ NEGATIVO'}

**Probabilidad:** {prediction_proba*100:.1f}%
**Riesgo:** {riesgo}
**Umbral:** {best_threshold:.2f}

**Valores:**
- Glucosa: {glucose} {'⚠️' if glucose > 140 else '✓'}
- IMC: {bmi:.1f} {'⚠️' if bmi > 30 else '✓'}
- Edad: {age} años

{'⚠️ Consulte a un médico' if prediction else '✓ Mantener hábitos saludables'}
"""
    except Exception as e:
        return f"❌ Error: {str(e)}"


# Interfaz
with gr.Blocks(theme=gr.themes.Soft(), title="Predicción Médica ML") as demo:

    gr.Markdown("""
    # 🏥 Sistema de Predicción Médica
    ### Machine Learning para Seguros y Diabetes

    **⚠️ Solo para fines educativos**
    """)

    with gr.Tab("💰 Seguros"):
        gr.Markdown("## Calculadora de Costos")

        with gr.Row():
            with gr.Column():
                age_input = gr.Slider(18, 100, value=30, step=1, label="Edad")
                sex_input = gr.Radio(["Masculino", "Femenino"], label="Sexo", value="Masculino")
                bmi_input = gr.Slider(15, 50, value=25, step=0.1, label="IMC")
                children_input = gr.Slider(0, 5, value=0, step=1, label="Hijos")
                smoker_input = gr.Radio(["Sí", "No"], label="¿Fumador?", value="No")
                region_input = gr.Dropdown(
                    ["Northeast", "Northwest", "Southeast", "Southwest"],
                    label="Región", value="Northeast"
                )
                insurance_btn = gr.Button("💰 Calcular", variant="primary")

            with gr.Column():
                insurance_output = gr.Markdown()
                gr.Examples(
                    examples=[[25, "Masculino", 22.0, 0, "No", "Northeast"],
                             [45, "Femenino", 32.0, 2, "Sí", "Southeast"]],
                    inputs=[age_input, sex_input, bmi_input, children_input,
                           smoker_input, region_input]
                )

        insurance_btn.click(
            predict_insurance,
            inputs=[age_input, sex_input, bmi_input, children_input,
                   smoker_input, region_input],
            outputs=insurance_output
        )

    with gr.Tab("🩺 Diabetes"):
        gr.Markdown("## Evaluador de Riesgo")

        with gr.Row():
            with gr.Column():
                pregnancies_input = gr.Slider(0, 20, value=1, step=1, label="Embarazos")
                glucose_input = gr.Slider(0, 200, value=120, step=1, label="Glucosa")
                bp_input = gr.Slider(0, 150, value=70, step=1, label="Presión")
                skin_input = gr.Slider(0, 100, value=20, step=1, label="Grosor Piel")
                insulin_input = gr.Slider(0, 900, value=80, step=1, label="Insulina")
                bmi_diab_input = gr.Slider(10, 70, value=25, step=0.1, label="IMC")
                dpf_input = gr.Slider(0.0, 3.0, value=0.5, step=0.01, label="Pedigrí")
                age_diab_input = gr.Slider(18, 100, value=30, step=1, label="Edad")
                diabetes_btn = gr.Button("🩺 Evaluar", variant="primary")

            with gr.Column():
                diabetes_output = gr.Markdown()
                gr.Examples(
                    examples=[[2, 110, 70, 20, 80, 23.0, 0.4, 28],
                             [6, 180, 90, 35, 200, 38.0, 1.5, 58]],
                    inputs=[pregnancies_input, glucose_input, bp_input, skin_input,
                           insulin_input, bmi_diab_input, dpf_input, age_diab_input]
                )

        diabetes_btn.click(
            predict_diabetes,
            inputs=[pregnancies_input, glucose_input, bp_input, skin_input,
                   insulin_input, bmi_diab_input, dpf_input, age_diab_input],
            outputs=diabetes_output
        )

    with gr.Tab("ℹ️ Info"):
        gr.Markdown(f"""
        ## Información del Sistema

        ### Modelos

        **Seguros:**
        - Modelo: Random Forest Optimizado
        - R²: {r2_score(y_test_ins, y_pred_rf_opt_ins):.4f}
        - Top factores: Fumador, BMI, Edad

        **Diabetes:**
        - Modelo: Random Forest Optimizado
        - Accuracy: {accuracy_score(y_test_diab, y_pred_rf_opt_diab):.4f}
        - Umbral: {best_threshold:.2f}
        - Top factores: Glucosa, BMI, Edad

        ### Respuestas

        1. **Umbral ideal:** {best_threshold:.2f}
        2. **Factores seguros:** Fumador, BMI, Edad
        3. **RF vs Lineal:** RF mejora en ambos casos
        4. **Mejor optimización:** Random Forest + GridSearchCV
        5. **Contexto:** Ver análisis exploratorio
        6. **Sesgo:** Fumadores en seguros, edad en diabetes

        ### Datasets
        - Insurance: {insurance_df.shape[0]} registros
        - Diabetes: {diabetes_df.shape[0]} registros

        ⚠️ **Solo para fines educativos**
        """)

print("\n✓ Interfaz creada")
print("\n" + "="*70)
print("LANZANDO APLICACIÓN...")
print("="*70)

demo.launch(share=True, debug=True)

print("\n🎉 ¡Listo! Usa la URL pública generada")

"""##Preparacion Subida a Github"""

# Ejecuta esto en Colab para preparar los archivos

import os
from google.colab import files

# Crear carpeta del proyecto
!mkdir -p medical-ml-project

# Guardar el notebook
print("📝 Guardando archivos...")

# 1. Crear requirements.txt
requirements = """pandas==2.0.3
numpy==1.24.3
scikit-learn==1.3.0
matplotlib==3.7.2
seaborn==0.12.2
gradio==4.44.0
plotly==5.17.0
scipy==1.11.2
"""

with open('medical-ml-project/requirements.txt', 'w') as f:
    f.write(requirements)
print("✓ requirements.txt creado")

# 2. Crear .gitignore
gitignore = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
*.egg-info/
dist/
build/

# Jupyter Notebook
.ipynb_checkpoints
*.ipynb

# Modelos entrenados
*.pkl

# Datos
*.csv
data/

# IDEs
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Gradio
gradio_cached_examples/
flagged/
"""

with open('medical-ml-project/.gitignore', 'w') as f:
    f.write(gitignore)
print("✓ .gitignore creado")

# 3. Crear script principal (app.py)
print("\n⚠️ IMPORTANTE: Guarda el código completo como 'app.py'")
print("   Puedes hacerlo manualmente o usar el siguiente comando:")

# 4. Crear carpeta de documentación
!mkdir -p medical-ml-project/docs
!mkdir -p medical-ml-project/images

print("\n✓ Estructura de carpetas creada")
print("\nEstructura del proyecto:")
print("""
medical-ml-project/
│
├── README.md                 (Lo crearemos a continuación)
├── requirements.txt          ✓
├── .gitignore               ✓
├── app.py                   (Guarda el código completo aquí)
├── insurance.csv            (Sube tu dataset)
├── diabetes.csv             (Sube tu dataset)
│
├── docs/
│   └── analisis.md          (Opcional: análisis detallado)
│
└── images/
    └── screenshots/         (Capturas de pantalla de la app)
""")

# Descargar archivos creados
print("\n Descargando archivos...")
files.download('medical-ml-project/requirements.txt')
files.download('medical-ml-project/.gitignore')

print("\n✅ Archivos preparados!")